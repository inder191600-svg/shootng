# -*- coding: utf-8 -*-
"""Untitled13.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ego3U8Q2VLwm15awvkSRhDB02lbmtANb
"""

# Run this if you get any errors
!pip install pygame numpy opencv-python-headless
!apt-get update
!apt-get install -y python3-pygame

# First, install required packages in Google Colab
!pip install pygame numpy opencv-python-headless

import pygame
import numpy as np
import cv2
import math
import random
from google.colab.patches import cv2_imshow

# Initialize PyGame
pygame.init()

# Game settings
WIDTH, HEIGHT = 800, 600
FPS = 60

# Colors
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 50, 50)
GREEN = (50, 255, 50)
BLUE = (50, 100, 255)
YELLOW = (255, 255, 50)
DARK_GRAY = (50, 50, 50)
LIGHT_GRAY = (150, 150, 150)
BROWN = (139, 69, 19)
SKY_BLUE = (135, 206, 235)
FLOOR_COLOR = (100, 100, 100)

class Player:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.angle = 0  # Direction player is facing (in radians)
        self.fov = math.pi / 3  # Field of view (60 degrees)
        self.speed = 0.1
        self.rotation_speed = 0.05
        self.health = 100
        self.score = 0
        self.ammo = 30

    def move_forward(self):
        new_x = self.x + math.cos(self.angle) * self.speed
        new_y = self.y + math.sin(self.angle) * self.speed
        # Check collision with walls
        if not game_map.is_wall(int(new_x), int(self.y)):
            self.x = new_x
        if not game_map.is_wall(int(self.x), int(new_y)):
            self.y = new_y

    def move_backward(self):
        new_x = self.x - math.cos(self.angle) * self.speed
        new_y = self.y - math.sin(self.angle) * self.speed
        if not game_map.is_wall(int(new_x), int(self.y)):
            self.x = new_x
        if not game_map.is_wall(int(self.x), int(new_y)):
            self.y = new_y

    def rotate_left(self):
        self.angle -= self.rotation_speed

    def rotate_right(self):
        self.angle += self.rotation_speed

class GameMap:
    def __init__(self, width=20, height=20):
        self.width = width
        self.height = height
        # 0 = empty, 1 = wall, 2 = enemy spawn, 3 = ammo, 4 = health
        self.grid = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ]

        # Add some random items
        for _ in range(10):
            x = random.randint(1, self.width-2)
            y = random.randint(1, self.height-2)
            if self.grid[y][x] == 0:
                self.grid[y][x] = random.choice([2, 3, 4])

    def is_wall(self, x, y):
        if 0 <= x < self.width and 0 <= y < self.height:
            return self.grid[int(y)][int(x)] == 1
        return True

    def get_cell_type(self, x, y):
        if 0 <= x < self.width and 0 <= y < self.height:
            return self.grid[int(y)][int(x)]
        return 1

class Enemy:
    def __init__(self, x, y):
        self.x = x + 0.5  # Center in cell
        self.y = y + 0.5
        self.health = 30
        self.speed = 0.03
        self.active = True
        self.color = RED
        self.size = 0.3

    def update(self, player_x, player_y):
        if not self.active:
            return

        # Move towards player
        dx = player_x - self.x
        dy = player_y - self.y
        dist = math.sqrt(dx*dx + dy*dy)

        if dist > 0:
            self.x += (dx / dist) * self.speed
            self.y += (dy / dist) * self.speed

            # Check collision with walls
            if game_map.is_wall(int(self.x), int(self.y)):
                self.x -= (dx / dist) * self.speed
                self.y -= (dy / dist) * self.speed

    def draw_minimap(self, screen, offset_x, offset_y, scale):
        if self.active:
            pygame.draw.circle(screen, self.color,
                              (int(offset_x + self.x * scale),
                               int(offset_y + self.y * scale)),
                              int(self.size * scale))

class Bullet:
    def __init__(self, x, y, angle):
        self.x = x
        self.y = y
        self.angle = angle
        self.speed = 0.3
        self.active = True
        self.distance = 0
        self.max_distance = 10

    def update(self):
        if not self.active:
            return

        self.x += math.cos(self.angle) * self.speed
        self.y += math.sin(self.angle) * self.speed
        self.distance += self.speed

        # Check collision with walls
        if game_map.is_wall(int(self.x), int(self.y)):
            self.active = False

        # Check max distance
        if self.distance > self.max_distance:
            self.active = False

        # Check collision with enemies
        for enemy in enemies[:]:
            if enemy.active and self.active:
                dx = enemy.x - self.x
                dy = enemy.y - self.y
                if math.sqrt(dx*dx + dy*dy) < enemy.size:
                    enemy.health -= 10
                    self.active = False
                    if enemy.health <= 0:
                        enemy.active = False
                        player.score += 100

class Game:
    def __init__(self):
        self.screen = pygame.Surface((WIDTH, HEIGHT))
        self.clock = pygame.time.Clock()
        self.running = True
        self.game_over = False

        # Raycasting settings
        self.num_rays = WIDTH // 2
        self.max_depth = 20
        self.cell_size = 1

        # Font
        self.font = pygame.font.SysFont(None, 24)
        self.big_font = pygame.font.SysFont(None, 48)

    def cast_ray(self, angle):
        # Ray direction
        ray_dir_x = math.cos(angle)
        ray_dir_y = math.sin(angle)

        # Player position
        ray_x = player.x
        ray_y = player.y

        # Ray step size
        delta_dist_x = abs(1 / ray_dir_x) if ray_dir_x != 0 else float('inf')
        delta_dist_y = abs(1 / ray_dir_y) if ray_dir_y != 0 else float('inf')

        # Initial step and side distance
        map_x = int(ray_x)
        map_y = int(ray_y)

        step_x = 1 if ray_dir_x >= 0 else -1
        step_y = 1 if ray_dir_y >= 0 else -1

        side_dist_x = (map_x + (1 if ray_dir_x >= 0 else 0) - ray_x) * delta_dist_x
        side_dist_y = (map_y + (1 if ray_dir_y >= 0 else 0) - ray_y) * delta_dist_y

        # DDA algorithm
        side = 0  # 0 = x-side, 1 = y-side
        depth = 0

        while depth < self.max_depth:
            if side_dist_x < side_dist_y:
                side_dist_x += delta_dist_x
                map_x += step_x
                side = 0
            else:
                side_dist_y += delta_dist_y
                map_y += step_y
                side = 1

            if game_map.is_wall(map_x, map_y):
                break

            depth += 0.1

        # Calculate distance
        if side == 0:
            perp_wall_dist = (map_x - ray_x + (1 - step_x) / 2) / ray_dir_x
        else:
            perp_wall_dist = (map_y - ray_y + (1 - step_y) / 2) / ray_dir_y

        # Calculate wall height
        line_height = HEIGHT / (perp_wall_dist + 0.0001)

        return perp_wall_dist, line_height, side

    def render_3d_view(self):
        # Draw sky
        pygame.draw.rect(self.screen, SKY_BLUE, (0, 0, WIDTH, HEIGHT // 2))

        # Draw floor
        pygame.draw.rect(self.screen, FLOOR_COLOR, (0, HEIGHT // 2, WIDTH, HEIGHT // 2))

        # Cast rays and draw walls
        ray_angle = player.angle - player.fov / 2

        for ray in range(self.num_rays):
            # Cast ray
            distance, line_height, side = self.cast_ray(ray_angle)

            # Calculate wall color based on distance and side
            if distance < self.max_depth:
                # Darken walls based on distance
                color_value = max(50, 255 - distance * 15)

                if side == 0:
                    wall_color = (color_value, color_value // 2, color_value // 2)  # Red-ish
                else:
                    wall_color = (color_value // 2, color_value // 2, color_value)  # Blue-ish

                # Draw wall slice
                wall_top = HEIGHT // 2 - line_height // 2
                wall_height = max(1, line_height)

                pygame.draw.rect(self.screen, wall_color,
                               (ray * 2, wall_top, 2, wall_height))

            ray_angle += player.fov / self.num_rays

    def render_minimap(self):
        # Draw minimap background
        map_size = 150
        map_x = WIDTH - map_size - 10
        map_y = 10

        pygame.draw.rect(self.screen, DARK_GRAY, (map_x, map_y, map_size, map_size))

        # Draw walls on minimap
        cell_size = map_size / game_map.width

        for y in range(game_map.height):
            for x in range(game_map.width):
                if game_map.grid[y][x] == 1:
                    pygame.draw.rect(self.screen, LIGHT_GRAY,
                                   (map_x + x * cell_size,
                                    map_y + y * cell_size,
                                    cell_size, cell_size))

        # Draw player on minimap
        player_map_x = map_x + player.x * cell_size
        player_map_y = map_y + player.y * cell_size

        pygame.draw.circle(self.screen, GREEN,
                          (int(player_map_x), int(player_map_y)),
                          int(cell_size // 2))

        # Draw player direction
        dir_x = player_map_x + math.cos(player.angle) * cell_size
        dir_y = player_map_y + math.sin(player.angle) * cell_size
        pygame.draw.line(self.screen, YELLOW,
                        (player_map_x, player_map_y),
                        (dir_x, dir_y), 2)

        # Draw enemies on minimap
        for enemy in enemies:
            if enemy.active:
                enemy.draw_minimap(self.screen, map_x, map_y, cell_size)

        # Draw bullets on minimap
        for bullet in bullets:
            if bullet.active:
                bullet_map_x = map_x + bullet.x * cell_size
                bullet_map_y = map_y + bullet.y * cell_size
                pygame.draw.circle(self.screen, YELLOW,
                                 (int(bullet_map_x), int(bullet_map_y)), 2)

    def render_ui(self):
        # Health bar
        pygame.draw.rect(self.screen, RED, (20, HEIGHT - 60, 200, 20))
        pygame.draw.rect(self.screen, GREEN, (20, HEIGHT - 60, 200 * (player.health / 100), 20))
        health_text = self.font.render(f"Health: {player.health}", True, WHITE)
        self.screen.blit(health_text, (20, HEIGHT - 85))

        # Ammo
        ammo_text = self.font.render(f"Ammo: {player.ammo}", True, WHITE)
        self.screen.blit(ammo_text, (20, HEIGHT - 35))

        # Score
        score_text = self.font.render(f"Score: {player.score}", True, WHITE)
        self.screen.blit(score_text, (WIDTH - 150, 20))

        # Controls hint
        controls = "WASD: Move | Mouse: Look | Click: Shoot | R: Reload"
        controls_text = self.font.render(controls, True, WHITE)
        self.screen.blit(controls_text, (WIDTH // 2 - controls_text.get_width() // 2, HEIGHT - 30))

        # Game over screen
        if self.game_over:
            overlay = pygame.Surface((WIDTH, HEIGHT), pygame.SRCALPHA)
            overlay.fill((0, 0, 0, 200))
            self.screen.blit(overlay, (0, 0))

            game_over_text = self.big_font.render("GAME OVER", True, RED)
            self.screen.blit(game_over_text,
                           (WIDTH//2 - game_over_text.get_width()//2,
                            HEIGHT//2 - 50))

            score_text = self.big_font.render(f"Final Score: {player.score}", True, GREEN)
            self.screen.blit(score_text,
                           (WIDTH//2 - score_text.get_width()//2,
                            HEIGHT//2))

            restart_text = self.font.render("Press R to restart or ESC to quit", True, WHITE)
            self.screen.blit(restart_text,
                           (WIDTH//2 - restart_text.get_width()//2,
                            HEIGHT//2 + 50))

    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False

            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    self.running = False

                elif event.key == pygame.K_r:
                    if self.game_over:
                        reset_game()

                elif event.key == pygame.K_SPACE and not self.game_over:
                    if player.ammo > 0:
                        bullets.append(Bullet(player.x, player.y, player.angle))
                        player.ammo -= 1

            # Mouse click for shooting
            elif event.type == pygame.MOUSEBUTTONDOWN and not self.game_over:
                if player.ammo > 0:
                    bullets.append(Bullet(player.x, player.y, player.angle))
                    player.ammo -= 1

        # Get mouse movement for looking around
        if pygame.mouse.get_focused() and not self.game_over:
            mouse_x, _ = pygame.mouse.get_rel()
            player.angle += mouse_x * 0.005

        # Get keyboard state for movement
        keys = pygame.key.get_pressed()
        if not self.game_over:
            if keys[pygame.K_w] or keys[pygame.K_UP]:
                player.move_forward()
            if keys[pygame.K_s] or keys[pygame.K_DOWN]:
                player.move_backward()
            if keys[pygame.K_a] or keys[pygame.K_LEFT]:
                player.rotate_left()
            if keys[pygame.K_d] or keys[pygame.K_RIGHT]:
                player.rotate_right()

    def update(self):
        if self.game_over:
            return

        # Update enemies
        for enemy in enemies:
            enemy.update(player.x, player.y)

            # Check collision with player
            dx = player.x - enemy.x
            dy = player.y - enemy.y
            if math.sqrt(dx*dx + dy*dy) < 0.5 and enemy.active:
                player.health -= 1
                if player.health <= 0:
                    self.game_over = True

        # Update bullets
        for bullet in bullets[:]:
            bullet.update()
            if not bullet.active:
                bullets.remove(bullet)

        # Check for items
        cell_type = game_map.get_cell_type(int(player.x), int(player.y))
        if cell_type == 3:  # Ammo
            player.ammo += 10
            game_map.grid[int(player.y)][int(player.x)] = 0
        elif cell_type == 4:  # Health
            player.health = min(100, player.health + 20)
            game_map.grid[int(player.y)][int(player.x)] = 0

    def draw(self):
        # Clear screen
        self.screen.fill(BLACK)

        # Render 3D view
        self.render_3d_view()

        # Render minimap
        self.render_minimap()

        # Render UI
        self.render_ui()

    def run_frame(self):
        # Handle events
        self.handle_events()

        # Update game state
        self.update()

        # Draw everything
        self.draw()

        # Convert PyGame surface to numpy array for display in Colab
        frame = pygame.surfarray.array3d(self.screen)
        frame = frame.transpose([1, 0, 2])
        frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)

        # Display frame
        cv2_imshow(frame)

        # Wait for next frame
        self.clock.tick(FPS)

        return self.running

# Global game objects
game_map = GameMap()
player = Player(1.5, 1.5)
enemies = []
bullets = []

# Create enemies from map
for y in range(game_map.height):
    for x in range(game_map.width):
        if game_map.grid[y][x] == 2:  # Enemy spawn
            enemies.append(Enemy(x, y))
            game_map.grid[y][x] = 0  # Clear spawn point

def reset_game():
    global game_map, player, enemies, bullets
    game_map = GameMap()
    player = Player(1.5, 1.5)
    enemies = []
    bullets = []

    # Create enemies from map
    for y in range(game_map.height):
        for x in range(game_map.width):
            if game_map.grid[y][x] == 2:
                enemies.append(Enemy(x, y))
                game_map.grid[y][x] = 0

# Main game loop for Google Colab
def main():
    print("3D Shooting Game - Raycasting Engine")
    print("=" * 50)
    print("Controls:")
    print("  - WASD or Arrow Keys: Move")
    print("  - Move Mouse: Look around")
    print("  - Mouse Click or SPACE: Shoot")
    print("  - R: Restart (when game over)")
    print("  - ESC: Exit game")
    print("\nGame Features:")
    print("  - 3D Raycasting engine")
    print("  - First-person perspective")
    print("  - Enemy AI that chases player")
    print("  - Collectible items (ammo, health)")
    print("  - Minimap display")
    print("\nThe game will appear below. Make sure to click on the game window.")

    # Hide mouse cursor
    pygame.mouse.set_visible(False)

    game = Game()

    # Run for a set number of frames
    for frame_count in range(3000):  # Run for 3000 frames (~50 seconds at 60 FPS)
        if not game.run_frame():
            print("Game ended by user.")
            break

        # Clear output between frames
        from IPython.display import clear_output
        clear_output(wait=True)

    # Show mouse cursor again
    pygame.mouse.set_visible(True)

    print(f"Game ended. Final score: {player.score}")
    print("Run this cell again to play more!")

# Start the game
if __name__ == "__main__":
    main()